# TextRPG (던전 앤 디스코드) 개발 가이드라인

### 1. 개요 (Overview)
- 이 문서는 '던전 앤 디스코드' 게임(`TextRPG` cog) 개발에 참여하는 개발자를 위한 공식 가이드입니다.
- 코드 스타일, 개발 절차, 데이터 관리 방법을 통일하여 프로젝트의 일관성을 유지하고 협업 효율을 높이는 것을 목표로 합니다.
- **개발에 참여하기 전, 반드시 아래 두 문서를 정독해주세요.**
    - **`docs/game_design_detail.md`**: 게임의 핵심 컨셉과 시스템에 대한 상세 설명서 (최우선 필독)
    - **`docs/game_plan.md`**: 전체적인 개발 로드맵과 데이터베이스 구조 요약

### 2. 프로젝트 구조 (Project Structure)
- **`cogs/text_rpg.py`**: 게임의 핵심 로직, 명령어, 이벤트 처리를 담당하는 메인 파일입니다.
- **`sql/`**: 데이터베이스 관련 스크립트를 관리하는 디렉토리입니다.
    - `create_game_tables.sql`: 프로젝트 초기 설정 시 모든 게임 관련 테이블을 한 번에 생성하는 스크립트입니다.
    - `sql/updates/`: 아이템, 몬스터, **종족, 직업, 계약** 등 정적(static) 데이터의 버전별 업데이트 스크립트를 저장하는 공간입니다.

### 3. 데이터베이스 스키마 가이드 (Database Schema Guide)
- **`game_characters` / `game_character_history`**: 캐릭터의 핵심 정보 및 사망 기록을 저장합니다.
- **`game_inventory`**: 캐릭터가 소유한 아이템 정보를 저장합니다. `is_equipped` 필드를 통해 장착 여부를, `is_identified` 필드를 통해 식별 여부를 관리합니다.
- **`game_covenants`**: 계약의 마스터 데이터를 저장하는 테이블입니다. 계약의 이름, 설명, 각 조항(권장/금지)의 내용, 그리고 권능/반발 효과를 트리거하는 로직의 식별자(identifier)를 포함합니다.
- **`game_character_covenants`**: 캐릭터와 계약의 관계를 저장하는 테이블입니다. 어떤 캐릭터(`character_id`)가 어떤 계약(`covenant_id`)과 관계를 맺었는지, 그리고 현재 `공헌도(contribution_score)`가 얼마인지를 기록합니다.

### 4. 핵심 시스템 구현 가이드 (Core System Implementation Guide)

#### 공물 및 계약 시스템 (Tribute & Covenant System)
- **개요**: 플레이어의 선택에 따라 동적으로 효과가 변하는 시스템으로, 구현 시 상태 관리에 주의가 필요합니다.
- **구현 순서**:
    1. **'석판' 오브젝트**: 던전 맵을 생성할 때, '석판'이라는 특수 오브젝트를 배치해야 합니다. 각 석판은 특정 `covenant_id`를 가집니다. 플레이어가 이 오브젝트와 상호작용하면 시스템이 시작됩니다.
    2. **공물(Tribute) 로직**:
        - 플레이어가 석판에 공물을 바치면, 해당 석판의 `covenant_id`와 플레이어의 `character_id`를 `game_character_covenants` 테이블에서 확인합니다.
        - 레코드가 없으면 새로 생성하고, 있으면 `contribution_score`를 업데이트합니다.
        - 공물의 종류와 가치에 따라 점수 증가량을 차등 적용하고, 디자인 문서에 명시된 '힌트'용 임시 버프를 부여합니다.
    3. **계약(Covenant) 로직**:
        - `contribution_score`가 특정 임계값을 넘으면, 플레이어에게 '계약'을 맺을 수 있는 UI를 제공합니다.
        - 계약이 체결되면, 캐릭터의 상태에 계약 효과를 적용해야 합니다. 이는 캐릭터의 턴이 진행될 때마다 `game_character_covenants` 테이블을 참조하여 권장/금지 조항의 충족 여부를 판단하는 방식으로 구현됩니다.
    4. **효과 적용 (권능/반발)**:
        - 계약 효과(버프, 디버프, 스킬 추가 등)는 **이벤트 기반**으로 처리하는 것을 권장합니다. 예를 들어, `on_turn_start`, `on_attack`, `on_kill` 과 같은 이벤트 핸들러 내부에서, 현재 캐릭터가 맺은 계약의 조항을 확인하고 그에 따른 '권능' 또는 '반발' 효과를 적용합니다.
        - 이를 위해 계약 효과를 정의한 별도의 모듈이나 클래스를 만들어 관리하는 것이 좋습니다.
    5. **압박 완화 장치 (`고요의 부적`)**:
        - 플레이어가 '고요의 부적' 아이템을 사용하면, 해당 캐릭터에게 '계약 정지' 상태와 남은 턴 수를 부여합니다.
        - 이벤트 핸들러들은 효과를 적용하기 전에 항상 이 '계약 정지' 상태를 먼저 확인하여, 상태가 활성화되어 있다면 계약 관련 로직을 건너뛰도록 구현해야 합니다.

### 5. 개발 워크플로우 (Development Workflow)

#### 새로운 기능/명령어 추가 시
1. **기획 확인**: `docs/game_design_detail.md`와 `docs/game_plan.md`에서 추가하려는 기능의 명세를 확인합니다.
2. **코드 작성**: `cogs/text_rpg.py`에 `@app_commands.command`를 사용하여 슬래시 명령어를 추가합니다.
3. **UI 구현**: 사용자와의 복잡한 상호작용이 필요할 경우, `discord.ui.View`와 `discord.ui.Button`을 활용하여 직관적인 인터페이스를 제공합니다.
4. **DB 연동**: 데이터베이스 접근이 필요할 때는 반드시 `database_manager.py`에 구현된 `execute_query` 함수를 통해 수행합니다.

#### 정적 데이터 (아이템, 몬스터, 종족, 직업 등) 추가/수정 시
> 이 절차는 봇의 자동화된 데이터 버전 관리 시스템을 따릅니다.

1. **버전 상수 수정**: `cogs/text_rpg.py` 파일 상단에 정의된 데이터 버전(예: `LATEST_RACE_VERSION`)의 숫자를 1 올립니다.
2. **업데이트 SQL 파일 생성**: `sql/updates/` 디렉토리에 `[데이터타입]_v[새로운 버전].sql` 형식으로 파일을 만듭니다.
    - 예시: 종족 데이터의 2번째 업데이트일 경우 `races_v2.sql` 파일을 생성합니다.
3. **쿼리 작성**: 생성한 SQL 파일에 `INSERT`, `UPDATE`, `DELETE` 등 필요한 쿼리를 작성합니다.
4. **자동 적용 및 확인**: 봇이 재시작되면 버전 관리 시스템이 코드와 DB의 버전 차이를 감지하고, 해당 SQL 스크립트를 자동으로 실행합니다. 초기 설정을 제외하고 수동으로 `/db실행` 명령을 호출하지 마세요. 개발 후에는 `/버전` 명령어를 실행하여 코드와 데이터 버전이 모두 정상적으로 적용되었는지 확인합니다.

### 6. 핵심 규칙 및 코딩 컨벤션 (Key Rules & Conventions)
- **버전 확인**: 개발 및 배포 후에는 `/버전` 명령어를 사용하여 현재 봇의 **코드 버전(Git)**과 **데이터 버전(DB)**이 의도한 대로 적용되었는지 반드시 확인합니다.
- **데이터베이스 접근**: 절대 `asyncpg`를 직접 호출하지 않고, 항상 `database_manager.py`의 래퍼(wrapper) 함수를 사용해야 합니다. 이는 연결 풀 관리와 에러 로깅을 중앙화하기 위함입니다.
- **에러 처리**: `try...except` 구문을 적극적으로 활용해 예상치 못한 오류를 처리합니다. 사용자에게는 `interaction.response.send_message("오류가 발생했습니다.", ephemeral=True)`와 같이 간결한 오류 메시지를 임시 메시지로 전달하고, 개발자가 확인할 수 있는 상세한 로그는 `sentry_sdk.capture_exception(e)`를 통해 기록합니다.
- **보안**: SQL 인젝션 공격을 방지하기 위해, 쿼리에 f-string이나 `+` 연산자로 변수를 직접 삽입하는 것을 금지합니다. 항상 `execute_query`의 `params` 인자를 사용하여 쿼리와 데이터를 분리하세요.
    - **Bad**: `await execute_query(f"SELECT * FROM users WHERE id = {user_id}")`
    - **Good**: `await execute_query("SELECT * FROM users WHERE id = $1", (user_id,))`
- **코드 스타일**: [PEP 8](https://peps.python.org/pep-0008/) 스타일 가이드를 준수하여 코드의 가독성과 일관성을 유지합니다. 