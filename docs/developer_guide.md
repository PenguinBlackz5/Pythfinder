# TextRPG (던전 앤 디스코드) 개발 가이드라인 (v2.0)

### 1. 문서의 목적과 독자
- **목적**: 이 문서는 '던전 앤 디스코드' 게임(`TextRPG` cog) 개발에 참여하는 모든 개발자를 위한 기술 지침서입니다. 코드 스타일, 아키텍처, 개발 절차를 통일하여 프로젝트의 일관성을 유지하고 협업 효율을 높이는 것을 목표로 합니다.
- **독자**: Pythfinder 프로젝트에 기여하고자 하는 Python 개발자.
- **필수 선행 지식**: `discord.py` 라이브러리에 대한 기본적인 이해가 필요합니다.
- **필독 문서**: 개발에 참여하기 전, 반드시 아래 두 문서를 정독하여 게임의 비전과 로드맵을 숙지해야 합니다.
    - **`docs/game_design_detail.md`**: 게임의 핵심 컨셉과 시스템에 대한 상세 설명서 (가장 중요)
    - **`docs/game_plan.md`**: 전체적인 개발 로드맵과 단계별 목표

---

### 2. 프로젝트 아키텍처 개요

이 게임은 여러 핵심 모듈의 유기적인 상호작용으로 구성됩니다. 개발자는 각 모듈의 역할과 책임(SRP)을 이해해야 합니다.

- **`cogs/text_rpg.py` (The Conductor)**
    - **역할**: 오케스트라의 '지휘자'. 사용자의 모든 입력(명령어, 버튼 클릭)을 최초로 수신합니다.
    - **책임**:
        - 사용자의 입력을 해석하여 어떤 게임 로직을 실행할지 결정합니다.
        - `GameManager`를 통해 게임 상태를 업데이트하도록 요청합니다.
        - `Renderer`를 통해 최종 게임 화면을 사용자에게 전송합니다.
        - **절대 직접 게임의 상태(예: `player.hp -= 10`)를 수정하지 않습니다.**

- **`game/` 디렉토리 (The Engine Room)**
    - **`game/game_manager.py`**: 게임의 모든 상태 변경을 책임지는 **중앙 관리자**입니다. `move_player`, `attack_monster` 등 게임 월드에 변화를 일으키는 모든 로직을 포함합니다.
    - **`game/player.py`, `game/dungeon.py` 등**: `Player`, `Dungeon`, `Item` 등 게임의 핵심 데이터 모델(Data Model)을 정의하는 클래스 파일들입니다.
    - **`game/renderer.py`**: 게임 상태(Game State) 객체를 입력받아, Discord 임베드와 버튼으로 구성된 최종 결과물을 생성하는 **렌더링 전문 모듈**입니다.

- **`database/database_manager.py` (The Archivist)**
    - **역할**: 데이터베이스와의 모든 상호작용을 전담하는 **유일한 창구**입니다.
    - **책임**: 안전한 쿼리 실행(SQL 인젝션 방지), 커넥션 풀 관리, 데이터 로딩 및 저장을 담당합니다.

---

### 3. 핵심 시스템 기술 가이드

#### 3.1. 렌더링 파이프라인 (Rendering Pipeline)
> **Phase 0**의 핵심 과업입니다.

- **원칙**: 게임 로직과 렌더링 로직은 **완벽하게 분리**되어야 합니다.
- **프로세스**:
    1. `text_rpg.py`가 사용자 입력을 받습니다.
    2. `text_rpg.py`는 `GameManager`의 함수(예: `game_manager.move_player('north')`)를 호출합니다.
    3. `GameManager`는 게임 상태(플레이어 위치, 몬스터 상태 등)를 변경하고, **업데이트된 게임 상태 객체**를 반환합니다.
    4. `text_rpg.py`는 이 게임 상태 객체를 `Renderer.render_game_screen()` 함수에 전달합니다.
    5. `Renderer`는 게임 상태를 기반으로 **뷰포트, UI, 버튼**을 생성하여 `discord.Embed`와 `discord.ui.View` 객체를 반환합니다.
    6. `text_rpg.py`는 반환된 `Embed`와 `View`를 사용자에게 전송합니다.

- **`Renderer` 구현 가이드**:
    - **뷰포트(Viewport)**: 전체 던전 맵에서 플레이어 주변의 `21x11` 영역만 잘라내어 렌더링합니다. 이모지의 시각적 일관성을 위해 **100% 이모지**를 사용하고, 정렬을 위해 항상 코드 블록(\`\`\`)으로 감쌉니다.
    - **시야(Field of View)**: `시야 내`, `기억 속`, `미탐험` 상태에 따라 각기 다른 이모지 셋을 사용하여 타일을 렌더링해야 합니다. 이 로직은 `Renderer` 내부에 캡슐화되어야 합니다.

#### 3.2. 상호작용 안정성 확보 (Interaction Stability)
> **Phase 0, 2**의 핵심 과업입니다. Discord API 속도 제한(Rate Limit)에 대응하고 안정적인 사용자 경험을 제공하기 위해 다음 기술을 반드시 적용해야 합니다.

- **입력 잠금 (Input Locking) - 이동/전투 시**:
    - **상황**: 플레이어가 이동/공격 버튼을 빠르게 연타할 경우.
    - **구현**:
        1. 사용자가 버튼을 클릭하면, `interaction.response.edit_message()`를 호출하기 **전에** 해당 `View`의 모든 버튼을 `disabled = True`로 설정하여 즉시 비활성화합니다.
        2. 모든 게임 로직(플레이어 이동, 몬스터 턴)을 처리합니다.
        3. 로직 처리가 끝난 후, 새로운 게임 화면을 렌더링할 때 버튼을 다시 활성화(`disabled = False`)하여 `edit_message`로 전송합니다.

- **디바운싱 (Debouncing) - 관찰하기 모드 시**:
    - **상황**: '관찰하기' 모드에서 플레이어가 관찰 커서를 빠르게 움직일 경우.
    - **구현**:
        1. '관찰 커서 이동' 버튼이 클릭되면, `interaction.response.edit_message()`를 바로 호출하지 않습니다.
        2. 대신, 마지막 입력으로부터 일정 시간(예: 400ms)을 기다리는 타이머를 설정합니다.
        3. 만약 타이머가 끝나기 전에 새로운 입력이 들어오면, 기존 타이머를 취소하고 새 타이머를 시작합니다.
        4. 타이머가 성공적으로 완료되었을 때만, **그 시점의 커서 위치**로 `edit_message`를 한 번만 호출합니다.
        5. `asyncio.sleep()`과 작업(task) 취소를 조합하여 구현할 수 있습니다.

#### 3.3. 절차적 던전 생성 (Procedural Dungeon Generation)
> **Phase 1**의 핵심 과업입니다. '방과 복도(Rooms and Corridors)' 알고리즘을 사용하여 논리적인 던전 구조를 생성합니다.

- **데이터 표현 (Data Representation)**:
    - 던전 맵은 **2차원 리스트(List of Lists)** 또는 `numpy` 배열로 표현됩니다. `map[y][x]` 형태로 접근합니다.
    - 각 타일은 `Tile` 객체이며, `terrain` (지형), `items` (아이템 리스트), `actor` (플레이어/몬스터) 등의 속성을 가집니다.

- **구현 단계 (Implementation Steps)**:
    1.  **맵 초기화**: `Dungeon` 클래스 생성자에서 주어진 너비와 높이에 맞춰, 모든 타일을 '벽'(`Tile(terrain='wall')`)으로 채운 2차원 배열을 생성합니다.
    2.  **방 배치 (Room Placement)**:
        - 무작위 크기와 위치를 가진 `Room` 객체를 여러 개 생성합니다.
        - 각 `Room` 객체는 다른 방과 겹치지 않는지 확인한 후, 맵 데이터에 `Tile(terrain='floor')`로 덮어씁니다.
    3.  **복도 생성 (Corridor Carving)**:
        - 모든 방을 연결하는 알고리즘(예: 가장 가까운 방을 직선으로 잇거나, 모든 방을 최소 신장 트리로 연결)을 사용하여 방 사이의 '벽' 타일을 '바닥' 타일로 변경합니다. 이 과정을 '조각(Carving)'이라고 합니다.
    4.  **특별 지형 배치**: 입구/출구 계단, 문, 함정, 석판 등의 특별한 타일/오브젝트를 논리적인 위치(예: 문은 방과 복도의 경계에)에 배치합니다.

---

### 4. 개발 워크플로우

#### 4.1. 새로운 기능/시스템 개발 시
1.  **로드맵 확인**: `docs/game_plan.md`에서 현재 개발 단계(Phase)와 목표를 확인합니다.
2.  **데이터 모델 정의**: `game/` 디렉토리에 필요한 클래스(데이터 컨테이너)를 설계합니다. (예: `Spell`, `Trap`)
3.  **DB 스키마 변경**: 필요 시 `sql/create_game_tables.sql`와 `sql/updates/`에 변경 사항을 반영합니다. (아래 4.2 절차 참고)
4.  **핵심 로직 구현**: `game/game_manager.py`에 새로운 게임 로직을 추가합니다.
5.  **렌더링 로직 구현**: `game/renderer.py`에 새로운 상태를 시각적으로 표현하는 코드를 추가합니다.
6.  **명령어/UI 연결**: `cogs/text_rpg.py`에서 사용자가 이 기능을 사용할 수 있도록 명령어와 버튼을 추가하고, `GameManager` 및 `Renderer`와 연결합니다.

#### 4.2. 정적 데이터 (아이템, 몬스터, 종족 등) 추가/수정 시
> 봇의 자동화된 데이터 버전 관리 시스템을 따르는 절차입니다.

1.  **버전 상수 수정**: `cogs/text_rpg.py` 파일 상단에 정의된 데이터 버전(예: `LATEST_RACE_VERSION`)의 숫자를 1 올립니다.
2.  **업데이트 SQL 파일 생성**: `sql/updates/` 디렉토리에 `[데이터타입]_v[새로운 버전].sql` 형식으로 파일을 만듭니다. (예: `races_v2.sql`)
3.  **쿼리 작성**: 생성한 SQL 파일에 `INSERT`, `UPDATE`, `DELETE` 등 필요한 쿼리를 작성합니다.
4.  **자동 적용 및 확인**: 봇을 재시작하면 버전 관리 시스템이 코드와 DB의 버전 차이를 감지하고, 해당 SQL 스크립트를 자동으로 실행합니다. 수동으로 `/db실행` 명령을 호출하지 마세요. 개발 후에는 `/버전` 명령어를 실행하여 코드와 데이터 버전이 모두 정상적으로 적용되었는지 확인합니다.

---

### 5. 코드 컨벤션 및 규칙

- **보안 (가장 중요)**: SQL 인젝션 공격을 방지하기 위해, **절대** f-string이나 `+` 연산자로 쿼리문에 변수를 직접 삽입하지 마세요. 항상 `database_manager.py`의 `execute_query` 함수에 `params` 인자를 사용하여 쿼리와 데이터를 분리해야 합니다.
    - **절대 금지**: `await execute_query(f"SELECT * FROM users WHERE id = {user_id}")`
    - **올바른 사용**: `await execute_query("SELECT * FROM users WHERE id = $1", params=(user_id,))`
- **에러 처리**: `try...except` 구문을 적극적으로 활용하되, 사용자에게는 `interaction.response.send_message("오류가 발생했습니다.", ephemeral=True)`와 같이 간결한 오류 메시지를 임시 메시지로 전달합니다. 개발자가 확인할 수 있는 상세한 예외 정보는 `sentry_sdk.capture_exception(e)`를 통해 기록합니다.
- **코드 스타일**: [PEP 8](https://peps.python.org/pep-0008/) 스타일 가이드를 준수합니다. 특히, 함수와 변수명은 `snake_case`를, 클래스명은 `PascalCase`를 사용합니다.
- **상수 관리**: 게임 밸런스에 영향을 주는 값(예: 뷰포트 크기, 디바운싱 시간)은 파일 상단에 대문자로 정의하여 관리합니다.
- **Git 커밋 메시지**: `feat: 로그인 기능 추가`, `fix: 아이템 복사 버그 수정`, `docs: 개발 가이드 업데이트` 와 같이 [Conventional Commits](https://www.conventionalcommits.org/) 스타일을 따라 명확하고 일관된 커밋 기록을 남깁니다. 